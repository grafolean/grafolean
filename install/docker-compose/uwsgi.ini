[uwsgi]
module = grafolean:app
uid = www-data
gid = www-data
master = true

# Because of the way uWSGI forks the process (first import, then fork) psycopg2 has trouble
# is number of processes is anything but 1. Threads are no problem though.
# But - if we want to maps sockets to workers, this only works with processes, so we *must*
# use them. This post explains the problem and suggests two solutions, postfork and lazy apps,
# of which lazy-apps is cleaner (and more wasteful).
#   https://engineering.ticketea.com/uwsgi-preforking-lazy-apps/
# Note that there is a drawback of lazy-apps that they use a lot of memory:
#   http://zarnovican.github.io/2016/02/15/uwsgi-graceful-reload/
processes = 7
#threads = 7
lazy-apps = yes

# We have two sockets; nginx uses appropriate one based on url. The reason is that our API
# updates mosquitto which in turn calls back our API for auth - but if this happens with
# all our workers simultaneously, there is no worker left to respond. So we need to make
# sure that some of the workers only respond to mqtt auth:
socket = /tmp/uwsgi.socket
socket = /tmp/uwsgi.mqtt-auth.socket

# Give 5 workers to http and 2 to mqtt auth:
map-socket=0:1,2,3,4,5
# The second socket will take the rest of the workers, no need to map it. But then it would be
# easy to forget that we must change the mapping whenever we change the number of processes:
map-socket=1:6,7

chmod-socket = 666
vacuum = true

# When enabled (set to True), only uWSGI internal messages and errors are logged.
disable-logging = False
# uwsgi logs to stdout / stderr by default, which is fine by us (docker will take care of the logs)
#logto = /tmp/uwsgi.log
#logto2 = /tmp/uwsgi2.log

# publish stats (for uwsgitop) via port 1717:
stats=:1717
memory-report = true

# when forking, do not pass sockets to child processes:
close-on-exec = true
# if a process hangs for 30s, restart it:
harakiri = 30
